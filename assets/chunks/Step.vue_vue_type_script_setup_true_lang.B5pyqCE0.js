import{P as F,r as a,d as B,a8 as m,T as O,af as b,a5 as C,l as P,a0 as g,o as h,c as H,K as E,w as V,a as T,p as i}from"./framework.BjhmxGx1.js";import{f as w}from"./vnode.DdFwp5CI.js";import{u as K}from"./index.BUKJqaQF.js";import{u as X}from"./index.BONkLgP_.js";import{r as S}from"./hook.B2gVniCM.js";import{n as x}from"./noop.DX6rZLP_.js";import{v as j,s as z}from"./index.CydGP8Vq.js";const $=Symbol("STEPS_CONTEXT");function I(){const o=F($,()=>(console.warn("<p-step> must be placed inside <p-steps>"),{next:x,prev:x,toStep:x,total:a(1),step:a(1),canPrev:a(!1),canNext:a(!1),onPrevHooks:a([]),onNextHooks:a([])}),!0),e=a([]),s=a([]);function l(t){e.value.unshift(t)}function c(t){s.value.unshift(t)}const n=async(...t)=>await S(e.value,...t),u=async(...t)=>await S(s.value,...t);return o.onPrevHooks.value.unshift(n),o.onNextHooks.value.unshift(u),j(()=>{const t=o.onPrevHooks.value.indexOf(n),r=o.onNextHooks.value.indexOf(u);t>-1&&o.onPrevHooks.value.splice(t,1),r>-1&&o.onNextHooks.value.splice(r,1)}),{...o,onBeforePrev:l,onBeforeNext:c}}const M=B({props:{active:{type:Number,default:0},keepAlive:{type:Boolean,default:!1},transition:{type:String,default:"slide-left"}},setup(o,{slots:e}){return()=>{const s=w(e.default(),"Step").at(o.active),l=()=>o.keepAlive?m(b,m(s,{key:o.active})):m(s,{key:o.active});return m(O,{name:o.transition,mode:"out-in"},l)}}}),R={class:"steps","data-testid":"steps"},Y=B({__name:"Steps",props:{modelValue:{type:Number,default:1},keepAlive:{type:Boolean,default:!1},direction:{type:String,default:"horizontal"},loop:{type:Boolean,default:!1},animation:{type:String,default:"slide"},onBeforePrev:{type:Function,default:()=>!0},onBeforeNext:{type:Function,default:()=>!0},onFinished:{type:Function,default:x}},emits:["update:modelValue"],setup(o){const e=o,s=C(),l=a([e.onBeforeNext]),c=a([e.onBeforePrev]),n=K(e),u=a(e.direction==="vertical"?"slide-top":"slide-left"),t=P(()=>w(s.default(),"Step").length),r=X(n,1,t),f=P(()=>e.loop||n.value<=t.value),v=P(()=>e.loop||n.value>1);async function k(){f.value&&await y(n.value+1)}async function _(){v.value&&await y(n.value-1)}async function y(p){const d=n.value,A=p>d?l.value:c.value,N=e.loop?((p-1)%t.value+t.value)%t.value+1:p;await S(A,N,d)&&(N<=t.value?(u.value=p>d?e.direction==="vertical"?`${e.animation}-top`:`${e.animation}-left`:e.direction==="vertical"?`${e.animation}-bottom`:`${e.animation}-right`,r.value=N):await e.onFinished())}return z(r,n),g($,{step:r,next:k,prev:_,total:t,canNext:f,canPrev:v,toStep:y,onPrevHooks:c,onNextHooks:l}),(p,d)=>(h(),H("div",R,[E(M,{active:i(r)-1,"keep-alive":o.keepAlive,transition:i(u)},{default:V(()=>[T(p.$slots,"default")]),_:3},8,["active","keep-alive","transition"])]))}}),U={class:"step","data-testid":"step"},Z=B({name:"Step",__name:"Step",props:{onBeforePrev:{type:Function,default:()=>!0},onBeforeNext:{type:Function,default:()=>!0}},setup(o){const e=o,{canNext:s,canPrev:l,toStep:c,step:n,total:u,next:t,prev:r,onBeforeNext:f,onBeforePrev:v}=I();return f(e.onBeforeNext),v(e.onBeforePrev),(k,_)=>(h(),H("div",U,[T(k.$slots,"default",{step:i(n),next:i(t),prev:i(r),total:i(u),canPrev:i(l),canNext:i(s),toStep:i(c)})]))}});export{Y as _,Z as a};
