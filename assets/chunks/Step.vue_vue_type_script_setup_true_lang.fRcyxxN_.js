import{L as F,p as a,d as B,a4 as m,T as O,aq as b,a1 as C,h as P,X as g,o as _,c as H,G as E,w as V,r as T,k as i}from"./framework.CI6Dj8yt.js";import{f as w}from"./vnode.CIR62YKX.js";import{u as X}from"./index.wZ2oc0_6.js";import{u as j}from"./index.DDyPugY2.js";import{r as S}from"./hook.B2gVniCM.js";import{n as x}from"./noop.DX6rZLP_.js";import{v as q,s as z}from"./index.C4QC3-vE.js";const $=Symbol("STEPS_CONTEXT");function G(){const o=F($,()=>(console.warn("<p-step> must be placed inside <p-steps>"),{next:x,prev:x,toStep:x,total:a(1),step:a(1),canPrev:a(!1),canNext:a(!1),onPrevHooks:a([]),onNextHooks:a([])}),!0),e=a([]),s=a([]);function l(t){e.value.unshift(t)}function c(t){s.value.unshift(t)}const n=async(...t)=>await S(e.value,...t),u=async(...t)=>await S(s.value,...t);return o.onPrevHooks.value.unshift(n),o.onNextHooks.value.unshift(u),q(()=>{const t=o.onPrevHooks.value.indexOf(n),r=o.onNextHooks.value.indexOf(u);t>-1&&o.onPrevHooks.value.splice(t,1),r>-1&&o.onNextHooks.value.splice(r,1)}),{...o,onBeforePrev:l,onBeforeNext:c}}const I=B({props:{active:{type:Number,default:0},keepAlive:{type:Boolean,default:!1},transition:{type:String,default:"slide-left"}},setup(o,{slots:e}){return()=>{const s=w(e.default(),"Step").at(o.active),l=()=>o.keepAlive?m(b,m(s,{key:o.active})):m(s,{key:o.active});return m(O,{name:o.transition,mode:"out-in"},l)}}}),K={class:"steps","data-testid":"steps"},Y=B({__name:"Steps",props:{modelValue:{type:Number,default:1},keepAlive:{type:Boolean,default:!1},direction:{type:String,default:"horizontal"},loop:{type:Boolean,default:!1},animation:{type:String,default:"slide"},onBeforePrev:{type:Function,default:()=>!0},onBeforeNext:{type:Function,default:()=>!0},onFinished:{type:Function,default:x}},emits:["update:modelValue"],setup(o){const e=o,s=C(),l=a([e.onBeforeNext]),c=a([e.onBeforePrev]),n=X(e),u=a(e.direction==="vertical"?"slide-top":"slide-left"),t=P(()=>w(s.default(),"Step").length),r=j(n,1,t),f=P(()=>e.loop||n.value<=t.value),v=P(()=>e.loop||n.value>1);async function k(){f.value&&await y(n.value+1)}async function h(){v.value&&await y(n.value-1)}async function y(p){const d=n.value,A=p>d?l.value:c.value,N=e.loop?((p-1)%t.value+t.value)%t.value+1:p;await S(A,N,d)&&(N<=t.value?(u.value=p>d?e.direction==="vertical"?`${e.animation}-top`:`${e.animation}-left`:e.direction==="vertical"?`${e.animation}-bottom`:`${e.animation}-right`,r.value=N):await e.onFinished())}return z(r,n),g($,{step:r,next:k,prev:h,total:t,canNext:f,canPrev:v,toStep:y,onPrevHooks:c,onNextHooks:l}),(p,d)=>(_(),H("div",K,[E(I,{active:i(r)-1,"keep-alive":o.keepAlive,transition:i(u)},{default:V(()=>[T(p.$slots,"default")]),_:3},8,["active","keep-alive","transition"])]))}}),L={class:"step","data-testid":"step"},Z=B({name:"Step",__name:"Step",props:{onBeforePrev:{type:Function,default:()=>!0},onBeforeNext:{type:Function,default:()=>!0}},setup(o){const e=o,{canNext:s,canPrev:l,toStep:c,step:n,total:u,next:t,prev:r,onBeforeNext:f,onBeforePrev:v}=G();return f(e.onBeforeNext),v(e.onBeforePrev),(k,h)=>(_(),H("div",L,[T(k.$slots,"default",{step:i(n),next:i(t),prev:i(r),total:i(u),canPrev:i(l),canNext:i(s),toStep:i(c)})]))}});export{Y as _,Z as a};
